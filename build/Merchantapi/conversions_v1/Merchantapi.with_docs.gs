
/**
 * Google Apps Script client library for the Merchant API
 * Documentation URL: https://developers.google.com/merchant/api
 * @class
 */
class Merchantapi {
  /**
   * @constructor
   * @param {object} [config] - Optional configuration object.
   * @param {string} [config.token] - An explicit OAuth2 token.
   * @param {object} [config.backoff] - Configuration for exponential backoff.
   */
  constructor(config = {}) {
    // "Private" properties using the underscore convention
    this._token = config.token || ScriptApp.getOAuthToken();
    this._backoffConfig = Object.assign({ retries: 3, baseDelay: 1000 }, config.backoff);
    this._rootUrl = 'https://merchantapi.googleapis.com/';
    this._servicePath = '';

    // --- Public Interface Initialization ---

    this.accounts = {};

    this.accounts.conversionSources = {};

    /**
     * Creates a new conversion source.
     * @param {string} params.parent - (Required) Required. The merchant account that will own the new conversion source. Format: `accounts/{account}`
     * @param {object} params.resource - The request body.
     * @return {object} The API response object.
     */
    this.accounts.conversionSources.create = (params) => this._makeRequest('conversions/v1/{+parent}/conversionSources', 'POST', params);

    /**
     * Updates information of an existing conversion source. Available only for Merchant Center Destination conversion sources.
     * @param {string} params.name - (Required) Output only. Identifier. Generated by the Content API upon creation of a new `ConversionSource`. Format: `[a-z]{4}:.+` The four characters before the colon represent the type of conversion source. Content after the colon represents the ID of the conversion source within that type. The ID of two different conversion sources might be the same across different types. The following type prefixes are supported: * `galk`: For GoogleAnalyticsLink sources. * `mcdn`: For MerchantCenterDestination sources.
     * @param {string} params.updateMask - Optional. List of fields being updated.
     * @param {object} params.resource - The request body.
     * @return {object} The API response object.
     */
    this.accounts.conversionSources.patch = (params) => this._makeRequest('conversions/v1/{+name}', 'PATCH', params);

    /**
     * Archives an existing conversion source. If the conversion source is a Merchant Center Destination, it will be recoverable for 30 days. If the conversion source is a Google Analytics Link, it will be deleted immediately and can be restored by creating a new one.
     * @param {string} params.name - (Required) Required. The name of the conversion source to be deleted. Format: `accounts/{account}/conversionSources/{conversion_source}`
     * @return {object} The API response object.
     */
    this.accounts.conversionSources.delete = (params) => this._makeRequest('conversions/v1/{+name}', 'DELETE', params);

    /**
     * Re-enables an archived conversion source. Only Available for Merchant Center Destination conversion sources.
     * @param {string} params.name - (Required) Required. The name of the conversion source to be undeleted. Format: `accounts/{account}/conversionSources/{conversion_source}`
     * @param {object} params.resource - The request body.
     * @return {object} The API response object.
     */
    this.accounts.conversionSources.undelete = (params) => this._makeRequest('conversions/v1/{+name}:undelete', 'POST', params);

    /**
     * Fetches a conversion source.
     * @param {string} params.name - (Required) Required. The name of the conversion source to be fetched. Format: `accounts/{account}/conversionSources/{conversion_source}`
     * @return {object} The API response object.
     */
    this.accounts.conversionSources.get = (params) => this._makeRequest('conversions/v1/{+name}', 'GET', params);

    /**
     * Retrieves the list of conversion sources the caller has access to.
     * @param {integer} params.pageSize - Optional. The maximum number of conversion sources to return in a page. If no `page_size` is specified, `100` is used as the default value. The maximum value is `200`. Values above `200` will be coerced to `200`. Regardless of pagination, at most `200` conversion sources are returned in total.
     * @param {string} params.pageToken - Optional. Page token.
     * @param {string} params.parent - (Required) Required. The merchant account who owns the collection of conversion sources. Format: `accounts/{account}`
     * @param {boolean} params.showDeleted - Optional. Show deleted (archived) conversion sources. By default, deleted conversion sources are not returned.
     * @return {object} The API response object.
     */
    this.accounts.conversionSources.list = (params) => this._makeRequest('conversions/v1/{+parent}/conversionSources', 'GET', params);
  }

  /**
   * @private Builds the full request URL and options object.
   */
  _buildRequestDetails(path, httpMethod, params) {
    let url = this._rootUrl + this._servicePath + path;
    const remainingParams = { ...params };
    // Fix: Correctly handle {+param} style parameters and other potential special chars.
    const pathParams = url.match(/{[^{}]+}/g) || [];

    pathParams.forEach(placeholder => {
      const isPlus = placeholder.startsWith('{+');
      const paramName = placeholder.slice(isPlus ? 2 : 1, -1);
      if (Object.prototype.hasOwnProperty.call(remainingParams, paramName)) {
        url = url.replace(placeholder, remainingParams[paramName]);
        delete remainingParams[paramName];
      }
    });

    const queryParts = [];
    for (const key in remainingParams) {
      if (key !== 'resource') {
        queryParts.push(`${encodeURIComponent(key)}=${encodeURIComponent(remainingParams[key])}`);
      }
    }
    if (queryParts.length > 0) {
      url += '?' + queryParts.join('&');
    }

    const options = {
      method: httpMethod,
      headers: { 'Authorization': 'Bearer ' + this._token },
      contentType: 'application/json',
      muteHttpExceptions: true,
    };
    if (params && params.resource) {
      options.payload = JSON.stringify(params.resource);
    }
    
    return { url, options };
  }

  /**
   * @private Makes the HTTP request with exponential backoff for retries.
   */
  _makeRequest(path, httpMethod, params) {
    const { url, options } = this._buildRequestDetails(path, httpMethod, params);

    for (let i = 0; i <= this._backoffConfig.retries; i++) {
      const response = UrlFetchApp.fetch(url, options);
      const responseCode = response.getResponseCode();
      const responseText = response.getContentText(); // Simplified call

      if (responseCode >= 200 && responseCode < 300) {
        return responseText ? JSON.parse(responseText) : {};
      }

      const retryableErrors = [429, 500, 503];
      if (retryableErrors.includes(responseCode) && i < this._backoffConfig.retries) {
        const delay = this._backoffConfig.baseDelay * Math.pow(2, i) + Math.random() * 1000;
        Utilities.sleep(delay);
        continue;
      }

      try {
        // Return parsed error if possible, otherwise a generic error object
        return JSON.parse(responseText);
      } catch (e) {
        return { error: { code: responseCode, message: responseText } };
      }
    }
    
    // This line is technically unreachable if retries >= 0, but good for safety.
    throw new Error('Request failed after multiple retries.');
  }
}
